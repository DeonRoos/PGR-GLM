---
title: 'Exercise'
# author: Deon Roos
output: 
  html_document: 
    code_folding: hide
    toc: false
editor_options: 
  chunk_output_type: console
---


```{r setup, echo=FALSE, purl = FALSE}
knitr::opts_chunk$set(echo=TRUE, message = FALSE, warning = FALSE, eval = FALSE, cache = FALSE)

SOLUTIONS <- FALSE
```

\  

# Exercise: Poisson GLM - predicting species richness

\  

For the GLM exercises, we'll use the workflow we suggested in the first GLM overview lecture as a template, specifically:

1. Know your research question!

2. Think about your response variable (stochastic).

3. Think about the process behind the data (deterministic).

4. Understand the data that you’ve collected (plot it!)

5. Combine into a model that can answer your question.

6. Fit the model.

7. Check your assumption(s).

8. Answer your question.

\

1\. Know your research question!

The researchers who collected this data wanted to describe the relationships between the number of species (`Species`) present in a plot of land, and how this number was associated with the overall plant biomass (`Biomass`, i.e. what was the overall weight of plants in the plot of land), and the pH of the soil (`pH`, categorised into "High", "Medium" and "Low"). The researchers were interested in describing the associations between species and the two explanatory variables. In total, the researchers collected data from 90 plots of land ($n = 90$), where each observation is from a single plot.

As concisely as possible, write down the research question that can be answered with our analysis. This might seem trivial in this case, but it's often one of the hardest parts of research; going from science to an actionable research question.

```{r Q1, eval=TRUE, echo=SOLUTIONS, results=SOLUTIONS, collapse=TRUE}
# How does biomass and pH relate to the number of plant species in a given plot of land?
```


2\. Think about your response variable (the stochastic element).

From the information provided in the brief above, we are already able to determine a suitable distribution to use when fitting the model (the fact that this practical is called Poisson GLM may also offer a rather cryptic hint...). The relevant information comes from the description of `Species` clearly indicating that this variable is a count, which implies 1) the minimum value is 0 [we cannot have -1 species], and 2) the response variable will be measured in integers [we cannot count 3.14 plants]. With this information alone, we can already deduce the *stochastic* element of our model (i.e. the error) should be adequately described by specifying a $Poisson$ distribution.

If you're comfortable doing so, write down the stochastic element of our model using statistical notation.

```{r}
# y ~ Poisson(lambda)
# Where
  # y is the count of species in a given plot
  # lambda is the rate parameter for the Poisson distribution
```


\

3\. Think about the process behind the data (the deterministic element).

Spare a moment's thought to how complex the process behind the number of plant species present in a plot of land will be. How much sunlight does each plot get? How much rainfall? What seeds were already present in the soil before data collection started? Why were *those* seeds present and not others? Why did some of them germinate in time for us to count them? We don't have any data to try and explain this variation, yet it will still be there (this is what we are tasking the stochastic part of the model to deal with).

For our purposes, we're interested in how plant biomass and soil pH affect species richness. If you're comfortable doing so, write down a sensible deterministic element for the model you would run, using statistical notation.

```{r Q3, eval=TRUE, echo=SOLUTIONS, results=SOLUTIONS, collapse=TRUE}
# log(lambda) = beta_0 + beta_1 * biomass + beta_2 * midpH + beta_3 * highpH
# Where
  # lambda is our linear predictor regressed on the log link scale
  # beta_0 defaults to low pH when biomass is equal to zero
  # beta_1 is the slope for biomass
  # beta_2 is the difference from low pH to mid pH
  # beta_3 is the difference from low pH to high pH
```

\  

4\. Understand the data that you’ve collected (plot it!)

We now get to the part where we'll actually start using `R`. A plea though - do not underestimate the value in taking the time to think carefully about the previous steps. Spending the time thinking about those questions makes your life that much easier. I'd estimate that for my own work, I spend at least 60% of my time thinking before doing anything with data or `R`. It really is that important.

4.1\. Get R ready to go

As in previous exercises, either create a new R script (perhaps call it GLM_Poisson) or continue with your previous R script in your RStudio Project. Again, make sure you include any metadata you feel is appropriate (title, description of task, date of creation etc) and  don't forget to comment out your metadata with a `#` at the beginning of the line. 

4.2\. Data exploration

Import the data file 'species.txt' into R and take a look at the structure of this dataframe. Given you have never seen this data before, it's really important that you familiarise yourself with any nuances. To help with this, carry out an initial data exploration (using any methods you think will help you get a sense of the data, e.g. `plot()`, `pairs()`, `coplot()`, amongst many other options).

While doing this, ask yourself:

* Do any of the variables need to be adjusted? (e.g. are factors recognised as such?)
* Do any factors need to be "re-levelled", such that it is read "Low", "Medium "High" (or any order we may prefer)?
  + (Hint: check `?factor` and look at the `levels` argument)
* Are there any relationships you can already see by eye alone?
* Are there any imbalances in any of the explanatory variables?
* Are there any observations that seem like they may be a data entry mistake?

If using `pairs()` to create a plot of the variables of interest, rather than creating a plot with every single variable in our dataset, we may prefer to restrict the plot to the variables we are actually interested in (this is redundant for this dataset but it's worth keeping this trick in mind for larger datasets). An effective way of doing this is to store the names of the variables of interest in a vector `VOI<- c("Var1", "Var2", ...)` and then use the list of variable names to subset the variables that get plotted (e.g. `pairs(Mydata[, VOI])`)

\  

```{r Q4, eval=TRUE, echo=SOLUTIONS, results=SOLUTIONS, collapse=TRUE}
sp <- read.table(file= "./data/species.txt", header= TRUE)

# Check the structure of the data to see if we need to correct anything
str(sp)

# Correct pH so it is read as a factor, reordered such that "low" is the reference level
sp$pH<- factor(sp$pH, levels = c("low", "mid", "high"))

# Get simple descriptives of the data (e.g. what is the range for each variable?)
summary(sp)

# make a list of the variables of interest, for convenience:
VOI<- c("Species", "Biomass", "pH")
pairs(sp[, VOI])
# Negative relationship between Species and Biomass?
# Positive relationship between Species and pH? 
# Biomass tends to increase with pH, which could generate
# some collinearity between these explanatory variables in a model.
# but still plenty of variation in Biomass within each pH, 
# so hopefully this won't be an issue.

coplot(Species ~ Biomass | pH, data = sp)
# the relationships looks consistently negative with biomass across the pH levels
```

5\. Combine into a model that can answer your question.

Having thought through the above details, it's now time to bring that information together into a single model. As a reminder, we want to describe the associations between species richness and plant biomass, and soil pH. Given this is the first practical session, we'll break this up for the sake of pedagogy. Let's start with species richness explained by biomass. Write the equation (not the `R` code) for this model (i.e. combine the stochastic and deterministic elements from Questions 3 and 4).

For example, an intercept-only $Poisson$ GLM would be:

$$
y_i \sim Poisson(\lambda_i)\\
log(\lambda_i) = \beta_0
$$

where, $y_i$ is the value of the response variable for the $i^{th}$ plot of land (e.g. if $i = 1$, then this indicates the first row of our dataset, or the first plot of land we have data for), assumed to follow a $Poisson$ distribution with rate $/lambda$, regressed on the $log$ link as a function of an intercept ($\beta_0$) only.

```{r Q5, eval=TRUE, echo=SOLUTIONS, results=SOLUTIONS, collapse=TRUE}
# y_i ~ Poisson(lambda_i)
# log(lambda_i) = beta_0 + beta_1 * Biomass
```


6\. Fit the model.

To warm up, let's start by a simpler model, where we assume that the number `Species` counted in a plot is a function of how much `Biomass` there was. We'll leave `pH` out of the model for the time being.

Run the model now, using `glm()`.

* Hints:
  + We use `family =` to specify the distribution in a `glm()`
    - "Family" is just an alternative way to refer to a distribution.
  + What is the default link function used by Poisson GLMs?
    - How do we specify it?
    - Do we need to specify it?
  + Use `?glm` if you're stuck, or ask for help.

\  

```{r Q6, eval=TRUE, echo=SOLUTIONS, results=SOLUTIONS, collapse=TRUE}
sp.glm1 <- glm(Species ~ Biomass, 
               family = poisson(link = "log"), 
               data = sp)
```

7\. Check your assumption(s).

Even though this isn't our final model, it can still be worthwhile to check how well this model met the assumptions.

To do so, we can check the model diagnostic plots, as well as check for dispersion. Do so now.

For the diagnostic plots:

+ Residuals vs Fitted
  * What kind of pattern would we expect?
+ Q-Q Residuals
  * Are we expecting Normally distribted error with a Poisson distribution?
+ Scale-Location
  * What is the maximum $\sqrt{|Std. PearsonResid|}$ we would be comfortable with?
+ Residuals vs Leverage
  * Are any observations having a strong influence on the model fit?

```{r Q7, eval=TRUE, echo=SOLUTIONS, results=SOLUTIONS, collapse=TRUE}
par(mfrow = c(2,2))
plot(sp.glm1)
par(mfrow = c(1,1))
summary(sp.glm1)

# Model diagnostic plots:
# Residuals vs Fitted
  # We see a fairly clear "funnel" pattern. We go from having relatively "little" variation
  # when our predicted values (on the link scale) are small, to "lots" of variation
  # when our predicted values are large, and most of this is happening between predicted
  # values of 2.5 to 3.5 (so over a fairly small range of predicted values)
  # This is would suggest we're not meeting the assumptions particularly well and
  # is a good indication that we have overdispersion.
# Q-Q Residuals
  # We completely ignore this figure for GLMs.
# Scale-Location
  # We also don't want to see any patterns (as for Resids vs Fitted) but we see the
  # same rapid increase in variation once predicted values are above 2.5
# Residuals vs Leverage
  # We're really only using this to check for values close to a Cook's distance of 1
  # While we don't have any observations that are greater than 1, we have a handful
  # that are getting uncomfortably close. While these values are fine, we're
  # not exactly jumping for joy with these Cook's distances.
# Overall, the diagnostic plots don't look great. Not the worst, but we'd want something
# better.

# To do a quick and crude check for dispersion, we can use the information from summary()
  # We take residual deviance and divide by the degrees of freedom, so for this model:
  # 432.63/88 = 4.9!
  # We have a whopping 4.9 overdispersion! My general rule of thumb is that I start getting
  # concerned when dispersion is somewhere in the 1.5-1.8 region. 4.9 is doomsday!
  # As a result, our standard error for our parameter estimates is going to be artificially
  # small. This in turn leads to both 1) risks of our p value being smaller than it should be
  # for Biomass, and 2) any predictions that include uncertainty being too confident.
```

8.\ Answer your question

Hopefully you identified issues that mean we should be very cautious with interpreting this simple version of the model. For now, we'll put these concerns to rest, and use this model as an opportunity to practice making predictions (and therefore answering our research question).

8.1.\ Go back to your equation that you wrote for question 5. Using `summary()`, replace the place-holder letters (e.g. $\beta_0$) with the estimated values from your model. Using this updated equation, make the following predictions:

* On the link scale, how many plants would you predict if a plot had 0 kg of biomass?

* On the link scale, how many plants would you predict if a plot had 2.5 kg of biomass?

* On the link scale, how many plants would you predict if a plot had 5 kg of biomass?

```{r Q8.1, eval=TRUE, echo=SOLUTIONS, results=SOLUTIONS, collapse=TRUE}
# On the link scale, how many plants would you predict if a plot had 0 kg of biomass?
3.55628 + -0.19598 * 0 # = 3.55628
# On the link scale, how many plants would you predict if a plot had 2.5 kg of biomass?
3.55628 + -0.19598 * 2.5 # = 3.06633
# On the link scale, how many plants would you predict if a plot had 5 kg of biomass?
3.55628 + -0.19598 * 5 # = 2.57638
```

8.2.\ Now, let's make predictions on the response scale. To go from the $log$ link scale, to the response scale, we take our predictions and apply the inverse link function to them. The inverse link function of $log$ is $e$ (or exponential, or `exp()`). Predict, on the response scale, how many plant species we would observe if:

* On the response scale, how many plants would you predict if a plot had 0 kg of biomass?

* On the response scale, how many plants would you predict if a plot had 5 kg of biomass?

* On the response scale, how many plants would you predict if a plot had 10 kg of biomass?

```{r Q8.2, eval=TRUE, echo=SOLUTIONS, results=SOLUTIONS, collapse=TRUE}
# On the response scale, how many plants would you predict if a plot had 0 kg of biomass?
exp(3.55628 + -0.19598 * 0) # = 35.0
# On the response scale, how many plants would you predict if a plot had 5 kg of biomass?
exp(3.55628 + -0.19598 * 5) # = 13.1
# On the response scale, how many plants would you predict if a plot had 10 kg of biomass?
exp(3.55628 + -0.19598 * 10) # = 4.9
```

8.3.\ Using this approach, we get a series of snapshot predictions. That's useful in and of itself, but we can make this a bit easier visually. To do so, rather copy-and-pasting our equation and substituting in different value of biomass, why not use `R` to make this a bit easier for us. Begin by using `seq()` to create a sequence of 5 biomass values that range from the minimum we observed in the data, to the maximum, and store this variable.

Hint: do not add this new biomass variable to your original dataset.

```{r Q8.3, eval=TRUE, echo=SOLUTIONS, results=SOLUTIONS, collapse=TRUE}
biomass_new <- seq(from = min(sp$Biomass), to = max(sp$Biomass), length.out = 5)
biomass_new
```

8.4.\ Once you have this variable (or "vector"), use it to make 5 simultaneous predictions of how many plant species we would expect to find, on the response scale. Store the output in another variable.

```{r Q8.4, eval=TRUE, echo=SOLUTIONS, results=SOLUTIONS, collapse=TRUE}
pred_plants <- exp(3.55628 + -0.19598 * biomass_new)
```

8.5.\ With both of these new variables, create a plot to show our prediction.

```{r Q8.5, eval=TRUE, echo=SOLUTIONS, results=SOLUTIONS, collapse=TRUE}
plot(pred_plants ~ biomass_new)
lines(pred_plants ~ biomass_new)
```

And with that, we have a prediction (from our model which we know has issues). If we stopped here, we'd conclude that biomass has a negative association with the number of plant species.

8.6.\ (Optional): The figure we have produced is pretty jagged looking. If we wanted a smoother line to be drawn, how would we do so?

```{r Q8.6, eval=TRUE, echo=SOLUTIONS, results=SOLUTIONS, collapse=TRUE}
# We would simply increase the number of biomass values that our seq() code created. Try it out if you're interested.
```

\  

9\. We've run a Poisson GLM where `Species` is explained by `Biomass`, but remember that our initial research question sought to describe the relationships between `Species` with both `Biomass` and `pH`. Before running this model, try to write down the equation for this new version of the model. Keep in mind that `pH` is a categorical variable, meaning we'll need additional covariates to indicate if an observation is, e.g. "Medium" pH (1) or not (0), or "High" pH (1) or not (0). (If you're not sure how to do this, you can either go back and watch the relevant sections of the Poisson lecture or ask for help). 

```{r Q9, eval=TRUE, echo=SOLUTIONS, results=SOLUTIONS, collapse=TRUE}
# y_i ~ Poisson(lambda_i)
# log(lambda_i) = beta_0 + beta_1 * biomass + beta_2 * pHmid + beta_3 * pHhigh

# Remember that for models with categorical variables, models will break that single 
# categorical column into however many levels there are minus 1. Here 2 columns 
# are "created" that are used to indicate if an observation is "mid" pH (1 if yes, 0
# if no), and another to indicate if an observation is "high" pH
# We don't need to column for "low", because if both "mid" and "high" are 0, then
# the only option is that it *must* be "low"
```

9.1.\ Once you've given that a shot, run the `glm()` which includes both `Biomass` and `pH` as main effects only (we won't be doing any interactions yet).

\  

```{r Q9.1, eval=TRUE, echo=SOLUTIONS, results=SOLUTIONS, collapse=TRUE}
sp.glm2 <- glm(Species ~ Biomass + pH, family = poisson(link = "log"), data = sp)
```

\  

10\. With every model we run, we need to re-diagnose the models. We've already done that once, so let's quickly do it again.

For the diagnostic plots:

+ Residuals vs Fitted
  * What kind of pattern would we expect?
+ Q-Q Residuals
  * Are we expecting Normally distribted error with a Poisson distribution?
+ Scale-Location
  * What is the maximum $\sqrt{|Std. PearsonResid|}$ we would be comfortable with?
+ Residuals vs Leverage
  * Are any observations having a strong influence on the model fit?

```{r Q10, eval=TRUE, echo=SOLUTIONS, results=SOLUTIONS, collapse=TRUE}
par(mfrow = c(2,2))
plot(sp.glm2)
par(mfrow = c(1,1))
summary(sp.glm2)

# Model diagnostic plots:
# Residuals versus Fitted
  # While we do still see a little bit of a funnel, it's a big improvement compared 
  # to previous model. This plot for the new model, while not perfect, is pretty good
# Q-Q Residuals
  # We completely ignore this figure (despite it looking nice in this model)
# Scale-Location
  # We also don't want to see any patterns. There's maybe a touch of increasing
  # error as our predictor gets larger, but not enough to concern me
# Residuals vs Leverage
  # We're really only using this to check for values close to a Cook's distance of 1
  # We can't even see the dashed lines showing a Cook's distance of 0.5, so we're
  # golden here too
# Overall, the diagnostic plots look great

# To do a quick and crude check for dispersion, we can use the information from summary()
  # We take residual deviance and divide by the degrees of freedom, so for this model:
  # 77.128/86 = 0.9
  # Not exactly the ideal value of 1 but 0.9 is nothing to get concerned about
  # Also, remember that *underdispersion* is generally not much of an issue
  # Compared to the first model, this is a fantastic improvement
```


11\. (Optional): Obtain and compare summaries of the model output using the `summary()` and the ANOVA of the model. 

* Which of the `drop1()` or `anova()` functions would you choose to use if you wanted to
  + look at deviance components?
  + explain the predictions?
  + test hypotheses?
  + carry out variable selection?

\  

```{r Q11, eval=TRUE, echo=SOLUTIONS, results=SOLUTIONS, collapse=TRUE}
anova(sp.glm2, test= "Chisq")
# DEVIANCE COMPONENTS:
# anova is useful for getting an idea of the relative contributions
# of each term to explaining the overall variability in the data,
# using the deviance. Beware that order does matter for all but the last term!

summary(sp.glm2)
# EXPLAINING PREDICTIONS:
# to explain patterns in the data, we need to look at the coefficient
# estimates from the summary of the model.

# TESTING HYPOTHESES:

# To test hyoptheses on the coefficient value being different from zero,
# look at the Z-test in the summary table

# To test hyoptheses on a predictor explaining a significant porportion of 
# variation in the data, look at the Chi-sq-test in the anova table

drop1(sp.glm2)
# VARIABLE SELECTION (SIMPLIFICATION):
# If we wanted to perform variable selection, we could use AIC to find
# any variables that we could drop from the model, without it loosing
# predictive power. In this example, the lowest AIC (the one with the best
# predictive power) is the full model (i.e. the one where we do not remove
# any variables)
```

\  

12\. Now that we've fit the full model, let's begin the process of interpreting what the results mean. For starters, given this is a more complex model, let's take it slowly and make sure we understand what each parameter estimate means. Using `summary()`, identify what each parameter means.

\  

```{r Q12, eval=TRUE, echo=SOLUTIONS, results=SOLUTIONS, collapse=TRUE}
summary(sp.glm2)
# "(Intercept)" is the predicted value on the link (log) scale when
# pH is "low". A hint is that there is no labelled coefficient called
# "pHlow".

# "Biomass" is the slope of Biomass.
# It is negative, so assumes a linear decrease (on the log scale)
# For every extra 1 unit (here kg) of biomass "added" to a plot
# the number of species (on the log scale) decreases by -0.16

# "pHmid" is the estimated difference (on the log scale) between
# the "pHmid" and the reference level, "pHlow".
# A value of 0.65 means plots with "mid" pH have 0.65 (on link scale)
# more species than "low" (our intercept).

# "pHhigh" is the estimated difference (on the log scale) between
# the "pHhigh" and the reference level, "pHlow".
# A value of 1.13 means plots with "mid" pH have 1.13 (on link scale)
# more species than "low" (our intercept).

# A mathematical description of the model
# (and how I would present it in the methods section of a paper):
# Species_i ~ Poisson(lambda_i)
# log(lambda_i) = 2.76 + -0.16 * Biomass_i
#    + 0.65 * pHmid_i
#    + 1.13 * pHhigh_i
```

\  

13\. Create full predictions and a figure to visualise your relationship

We can use the same technique we used for the model with just biomass, but now extend it to include the differing levels of pH. In addition, rather than manually writing out the equation (and possibly making mistakes), we can use the `predict()` function to just do it for us. A trick we can use here is to make use of the `expand.grid()` function, to create a new dataset that has a sequence of biomass values, that is replicate for each level of pH. To do so, we need to specify the range of values for both `biomass` and `ph`. We already did this for `biomass`, and it's pretty easy to do for `ph` as well: `c("Low", "Medium", "High")`. With that, we can use the following code:

`synth_data <- expand.grid(Biomass = seq(from = min(dat$Biomass), to = max(dat$Biomass), length.out = 5), pH = c("low", "mid", "high"))`

to create a new *synthetic* dataset, which we can use in the `predict()` function:

`synth_data$pred <- predict(sp.glm2, newdata = synth_data)` 

A hint: we can tell the `predict()` function to use the inverse link function automatically when making the predictions, so we don't need to by setting `type = "response"` or else we could always do this manually by exponentiating our predicted values. 

Using your synthetic dataset and model, create predictions of species richness. Once done, then use these to create a figure to show your predicted relationships for pH and biomass.

```{r Q14, eval=TRUE, echo=SOLUTIONS, results=SOLUTIONS, collapse=TRUE, fig.height=8, fig.show= ifelse(SOLUTIONS, "asis", "hide")}
synth_data <- expand.grid(Biomass = seq(from = min(sp$Biomass), to = max(sp$Biomass), length.out = 20), 
                          pH = c("low", "mid", "high"))

synth_data$pred <- predict(sp.glm2, newdata = synth_data, type = "response")

plot(sp$Biomass, sp$Species, col= sp$pH, xlab= "Biomass", ylab= "Number of species")

lines(synth_data$pred[synth_data$pH == "low"] ~ 
      synth_data$Biomass[synth_data$pH == "low"], lty= 1, col= 1)
lines(synth_data$pred[synth_data$pH == "mid"] ~ 
      synth_data$Biomass[synth_data$pH == "mid"], lty= 1, col= 2)
lines(synth_data$pred[synth_data$pH == "high"] ~ 
      synth_data$Biomass[synth_data$pH == "high"], lty= 1, col= 3)

legend("topright", 
 legend= c("high", "mid", "low"), 
 col= c(3:1), 
 lty= c(1, 1, 1), 
 lwd= c(1, 1, 1))
```

14\. (Optional) Exploring model diagnostics

One of the most challenging aspects in learning GLMs is how to determine if there is a problem in model diagnostics. Overwhelmingly, this is because a lot of this relies on gaining enough experience to know when there is a problem or not. To that end, as an optional exercise, we include code to simulate data, run a $Poisson$ GLM, and perform model diagnostics on with the aim of giving you a flexible means to gain some experience. The benefit of having you simulate datasets is that you know what the *Truth* is, because you decide what it is. With that anchor in place, you can then gauge when tools are reliable and when they are not. In general, simulating datasets and testing your statistical models is an excellent approach and one that is well worth building into your data analysis workflow (ideally before ever collecting real data).

The code to do the simulation can be found below, but is generated (often called the *Data Generating Process*, or DGP, in both code or real data sets) as:

$y_i \sim Poisson(\lambda_i)$

$log(\lambda_i) = \beta_0 + \beta_1 \times x_{1,i} + \beta_2 \times x_{2,i} + \beta_3\times x_{3,i}$

Rerun the simulation and analysis varying the sample size (`N <- 1000`) or the formula of the `glm()` (e.g. `y ~ x1 + x2`). Check what effect this has on dispersion and the model diagnostic plots.

```
# Set your seed to have the randomness be cosnsitent each time you run the code
# You can change this, or comment it out, if you want to embrase the randomness
set.seed(1234)

# Set your sample size
N <- 500

# Create two continuous covariates
x1 <- runif(N, 0, 10)
x2 <- runif(N, 0, 10)
x3 <- runif(N, 0, 10)

# Set your parameter values
beta_0 <- 2.5   # This is the intercept (on link scale)
beta_1 <- 0.2   # This is the slope for the x1 variable (on link scale)
beta_2 <- -1.3  # This is the slope for the x2 variable (on link scale)
beta_3 <- 0.4   # This is the slope for the x3 variable (on link scale)

# Generate your linear predictor on the link scale (i.e. log)
# We don't actually need to use log() here (it's already on the link scale)
linear_predictor_link <- beta_0 + beta_1 * x1 + beta_2 * x2 + beta_3 * x3
# Backtransform your linear predictor to the response scale (i.e. exponentiate)
linear_predictor_response <- exp(linear_predictor_link)
# Generate your response variable
y <- rpois(N, lambda = linear_predictor_response)
# Note that the above three lines of code are the equivalent to:
# y ~ Poisson(lambda)
# log(lambda) = beta_0 + beta_1 * x1 + beta_2 * x2

# Store your data in a dataframe
dat <- data.frame(y, x1, x2, x3)

# Run a Poisson GLM
fit <- glm(y ~ x1 + x2 + x3, 
           data = dat, 
           family = poisson)

# See if the model was able to estimate your parameter values
summary(fit)

# See how well the model diagnostics perform
par(mfrow = c(2,2))
plot(fit)
```

**End of the Poisson GLM - predicting species richness exercise**

