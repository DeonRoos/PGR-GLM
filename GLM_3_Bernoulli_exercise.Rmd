---
title: 'Day 3: Bernoulli GLMs'
# author: Deon Roos
output: 
  html_document:
    toc: false
    code_folding: hide
editor_options: 
  chunk_output_type: console
---


```{r setup, echo=FALSE, purl = FALSE}
knitr::opts_chunk$set(echo=TRUE, message = FALSE, warning = FALSE, eval = FALSE, cache = FALSE)

SOLUTIONS <- FALSE
```

\  

# Bernoulli GLM - Predicting if Netflix users will watch Lord of the Rings: The Fellowship of the Ring

\  

For the GLM exercises, we'll use the workflow we suggested in the first GLM overview lecture as a template, specifically:

1. Know your research question!

2. Think about your response variable (stochastic).

3. Think about the process behind the data (deterministic).

4. Understand the data that you’ve collected (plot it!)

5. Combine into a model that can answer your question.

6. Fit the model.

7. Check your assumption(s).

8. Answer your question.

\

### 1. Know your research question!

\

For this final exercise, we'll do something that's, hopefully, a bit fun and silly. We're going to work with a relatively small Netflix dataset, where we're going to try and *predict* if a user will will watch Lord of the Rings: The Fellowship of the Ring. I will admit to a number of ulterior motivations in ending the course using this dataset.

1. There is a common misconception that Machine Learning is for predicting and Statistics is for understanding. I want to show that this distinction is meaningless. In truth, machine learning is, in general, statistics performed (or in some cases developed) by computer scientists. For example, the GLMs you've learned to use on this course are often called Supervised Machine Learning Models in Machine Learning courses. The distinction between the two methods largely comes down to who is teaching you (and who taught them). Indeed, some "classic" machine learning methods such as Random Forest models are just GLMs with a few extra bells and whistles in much the same way that some "classic" statistical methods such as Mixed Effects models are just GLMs with a few extra bells and whistles.

2. Because people tend to think of there being some sort of distinction between Machine Learning and Statistics, it can result in people, such as yourselves, not realising they have skill-sets that lots of employers (including non-academic) are looking for. By using this Netflix example I want to show that, having taken this course, your employment options have broadened.

3. In the final and corresponding $Bernoulli$ GLM lecture, I showed an example where AIC fails miserably. In doing so, I'm at risk of leaving you with the impression that AIC (and also other forms of model and variable selection) should never be used. Therefore, in this exercise we're going to use an example where AIC is wonderfully well suited for helping achieve our objective. It will also give me an opportunity to talk a little more about how AIC works, and also the controversy and differing opinions on AIC.

4. I really like Lord of the Rings.

While this exercise takes on an industry focus, this is not specific to $Bernoulli$ GLMs. Indeed, like all GLMs and LMs, $Bernoulli$ GLMs can be used for any of the three broad purposes we described in the first lecture: Causal inference, prediction or description.

The data you've been provided includes various information that Netflix has on hand about their users, for the purposes of predicting if a user will watch Lord of the Rings (LoTR). To do so, our response variable if whether not a given viewer watched LoTR (1) or not (0).

The covariates we have are:
* `user` - a unique user ID
* `lotr` - if that user watched LoTR on Netflix
* `premium` - if the user has Netflix Premium or Standard
* `age` - the age of the user at the time of data collection
* `genre_likes` - how many fantasy films/shows the user had previously liked
* `actor_likes` - how many films/shows the user had previously liked that included cast members of LoTR
* `similar_user_ratins` - what lotr of "similar" users had liked LoTR ("similar" is undefined)
* `mean_time_genre` - what is the average length of time users watch fantasy media
* `user_time` - Time of day for user at time of data collection (`Morning`, `Afternoon` and `Evening`)
* `user_day` - Day of week for user at time of data collection (`Monday`, `Tuesday`, etc.)
* `user_device` - Type of device user was logged in from (`TV`, `PC`, `Mobile Device` and `Gaming Device`)
* `fam_members` - Number of family member accounts tied to subscription
* `country` - Country of subscription

As concisely as possible, write down the research question that can be answered with our analysis, keeping in mind that Netflix are not interested in understanding causation or writing a scientific paper, they want predictive power. 

```{r Q1, eval=TRUE, echo=SOLUTIONS, results=SOLUTIONS, collapse=TRUE}
# Using the available covariates, can Lord of the Rings engagement be predicted 
# and can we make this prediction as efficient as possible?
```

\

### 2. Think about your response variable (the stochastic element).

\

From the information provided in the description above, we can determine that a $Bernoulli$ distribution is a sensible one to use here; our data is 0 (user did not watch LoTR) or 1 (user did watch LoTR). Our stochastic element of the model would therefore be:

$y_i \sim Bernoulli(p_i)$

Where $y$ is if user $i$ watched LoTR or not, generated according to a $Bernoulli$ distribution, with probability $p$.

\

### 3. Think about the process behind the data (the deterministic element).

\

Just like the drinking coffee example from the first lecture, the *Data Generating Process* (DGP) for whether or not someone watches a particular film on Netflix is going to be incredibly complex. A nuance here is that our objective and intended use for this analysis is prediction. When that's the case, we can be a bit more relaxed about understanding the deep complexity underlying the DGP and instead feel relatively comfortable adding any and all covariates for which we have data, with an important caveat. We must be confident that we are not including any covariates which have no conceivable connection to our response. For example, we wouldn't want to include average sea surface temperature because it shouldn't give us any predictive power. But if we're unlucky, it may be correlated (by pure chance) with LoTR viewership and thus we may think it helps us do predictions (see [this](https://www.tylervigen.com/spurious-correlations) website for fun examples of such spurious correlations).

In this dataset, Netflix have collected covariates for the explicit purpose of predicting viewership, so we can be confident that at least *someone* thinks these variables might give us some predictive power and aren't spurious correlations.

With that said, our model will still have a deterministic equation that describes the associations. Given how many variables we have it would be cruel to task you with writing the equation out in full for a model that contains all of those covariates. Instead, assume our model was `lotr ~ age + user_time`. Use this simplified version of the model to write out the equation that would underpin it. Note that `age` is a continuous variable, and `user_time` is a categorical variable with the levels `Morning`, `Afternoon` and `Evening`.

For this equation, I'm not giving any hints so the difficulty does spike here. If you're struggling, ask for help. It really is worthwhile learning how the syntax `lotr ~ age + user_time` is translated into an equation, especially when you're ready to go beyond GLMs.

$logit(p_i) = \text{___}$

```{r Q3, eval=TRUE, echo=SOLUTIONS, results=SOLUTIONS, collapse=TRUE}
# With the blanks filled in, the equation should be:
# logit(p_i) = beta_0 + beta_1 * Age_i + beta_2 * Evening_i + beta_3 * Morning_i

# Why have I included Evening and then Morning, and not Afternoon?
# Because R will take the level that appears first alphanumerically, and use 
# that as the intercept (here *A*fternoon)
# If we wanted Morning to be the reference level, what R code would we use?
```

\  

### 4. Understand the data that you’ve collected (plot it!)

\

Import the data file 'netflix.txt' into R. Take a look at the structure of the data and create plots that you feel will help you (and others) understand the data.

Keep the tips and tricks you used in yesterday's practical and feel free to use them again here; load in the data, check for any covariates you need to adjust, plot out the data, etc.

A bit of advice for visualising $Bernoulli$ data; adding a little noise to the x and y-axis values for each point (i.e. jittering) helps immensely for visualising. To do so using `base` `R`, the code would be:

```
plot(jitter(my_data$y) ~ my_data$x)
```

As in yesterday's lecture and exercise, the my figures below are produced using `ggplot2` and are included purely for inspiration. I am also using an additional package, `patchwork`, to stitch together multiple figures into a single panel.

```{r Q4, eval=TRUE, echo=SOLUTIONS, results=SOLUTIONS, collapse=TRUE}
netflix <- read.table(file= "./data/netflix.txt", header = TRUE)

# Change variables from characters to factors
netflix$user <- factor(netflix$user)
netflix$premium <- factor(netflix$premium)
netflix$user_time <- factor(netflix$user_time, levels = c("Morning", "Afternoon", "Evening"))
netflix$user_day <- factor(netflix$user_day, 
                           levels = c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"))
netflix$user_device <- factor(netflix$user_device)
netflix$country <- factor(netflix$country)

str(netflix)
# 'data.frame':	15000 obs. of  13 variables:
#  $ user                : Factor w/ 15000 levels "0014074f-9304-4349-b1df-565122630bfa",..: 13625 2447 4081 ...
#  $ lotr                : int  0 1 1 1 0 0 0 0 0 1 ...
#  $ premium             : Factor w/ 2 levels "Premium","Standard": 2 2 2 2 2 2 2 2 2 1 ...
#  $ age                 : int  30 26 27 39 37 37 43 40 36 38 ...
#  $ genre_likes         : int  2 2 2 2 0 2 1 5 2 5 ...
#  $ actor_likes         : int  3 2 4 0 4 3 2 0 4 6 ...
#  $ similar_user_ratings: num  0.62 0.67 0.92 0.75 0.46 0.59 0.77 0.62 0.67 0.54 ...
#  $ mean_time_genre     : num  38.3 66.9 118.4 217.4 127.8 ...
#  $ user_time           : Factor w/ 3 levels "Afternoon","Evening",..: 1 2 1 1 2 1 2 2 2 3 ...
#  $ user_day            : Factor w/ 7 levels "Friday","Monday",..: 5 2 3 4 1 3 1 4 3 3 ...
#  $ user_device         : Factor w/ 4 levels "Gaming Device",..: 4 4 4 4 4 4 4 4 1 2 ...
#  $ fam_members         : int  3 3 2 0 1 2 1 2 2 1 ...
#  $ country             : Factor w/ 7 levels "DE","FR","JP",..: 2 6 7 5 7 6 2 6 6 4 ...

summary(netflix)
 #                                   user            lotr            premium           age         genre_likes   
 # 0014074f-9304-4349-b1df-565122630bfa:    1   Min.   :0.0000   Premium : 3001   Min.   : 7.00   Min.   :0.000  
 # 0017781d-22a6-41d1-9c61-10427b20f846:    1   1st Qu.:0.0000   Standard:11999   1st Qu.:24.00   1st Qu.:1.000  
 # 001f0d02-282e-4812-87b3-723e978da027:    1   Median :1.0000                    Median :29.00   Median :2.000  
 # 0021ddf2-ef09-4abe-b27d-d3fa74fd92b7:    1   Mean   :0.5278                    Mean   :29.98   Mean   :1.998  
 # 0023c3d4-ba8f-4716-8c30-6d6859c77b85:    1   3rd Qu.:1.0000                    3rd Qu.:35.00   3rd Qu.:3.000  
 # 00295ab4-6930-4d7e-b678-b10a65c0f234:    1   Max.   :1.0000                    Max.   :79.00   Max.   :9.000  
 # (Other)                             :14994                                                                    
 #  actor_likes     similar_user_ratings mean_time_genre     user_time         user_day           user_device   
 # Min.   : 0.000   Min.   :0.0300       Min.   :  0.0   Afternoon:4419   Friday   :2724   Gaming Device: 1535  
 # 1st Qu.: 2.000   1st Qu.:0.5300       1st Qu.: 79.9   Evening  :9104   Monday   :1698   Mobile Device: 2066  
 # Median : 3.000   Median :0.6900       Median :120.1   Morning  :1477   Saturday :2792   PC           : 1223  
 # Mean   : 2.973   Mean   :0.6661       Mean   :120.5                    Sunday   :3150   TV           :10176  
 # 3rd Qu.: 4.000   3rd Qu.:0.8300       3rd Qu.:160.3                    Thursday :1805                        
 # Max.   :12.000   Max.   :1.0000       Max.   :344.2                    Tuesday  :1352                        
 #                                                                        Wednesday:1479                        
 #  fam_members    country  
 # Min.   :0.000   DE:2476  
 # 1st Qu.:1.000   FR:2119  
 # Median :2.000   JP: 302  
 # Mean   :1.992   MX:1753  
 # 3rd Qu.:3.000   NZ: 728  
 # Max.   :9.000   UK:2825  
 #                 US:4797  

# install.packages("ggplot2") # Run this line of code if you do not have ggplot installed
# Once installed, load the package
library(ggplot2)

# I'll use another package called `patchwork` that helps combine ggplot figure together
# install.packages("patchwork") # Run this line of code if you do not have patchwork installed
# Once installed, load the package
library(patchwork)

# Not needed but downloading netflix icon to add to figure to give that corporate feel
# If you want to do this, you'll need to install the `png` package
library(png)
logo <- readPNG("./images/netflix.png")

# Bar chart showing total number of views according to account type
p1 <- ggplot(netflix) +
  geom_col(aes(x = premium, y = lotr), linetype = 1,
           alpha = 0.8, colour = "#E50914") +
  labs(x = "Subscription type",
       y = "Total number of\nLord of The Rings views") +  
  theme_classic() +
  annotation_raster(logo, 
                    xmin = 0.5, xmax = 1,
                    ymin = 4000, ymax = 6000)

# A scatterplot for lotr ~ age, jittered
p2 <- ggplot(netflix) +
  geom_jitter(aes(x = age, y = lotr), 
              width = 0, height = 0.3,
              colour = "#E50914", alpha = 0.05) +
  scale_y_continuous(labels = function(y) ifelse(y == 0, "No", ifelse(y == 1, "Yes", y)),
                     breaks = c(0, 1)) +
  labs(x = "User age",
       y = "Viewed\nLord of The Rings") +
  theme_classic()

# A scatterplot for lotr ~ genre_likes, jittered
p3 <- ggplot(netflix) +
  geom_jitter(aes(x = genre_likes, y = lotr), 
              width = 0.3, height = 0.3,
              colour = "#E50914", alpha = 0.05) +
  scale_y_continuous(labels = function(y) ifelse(y == 0, "No", ifelse(y == 1, "Yes", y)),
                     breaks = c(0, 1)) +
  labs(x = "Number of fantasy likes",
       y = "Viewed\nLord of The Rings") +
  theme_classic()

# A scatterplot for lotr ~ actor_likes, jittered
p4 <- ggplot(netflix) +
  geom_jitter(aes(x = actor_likes, y = lotr), 
              width = 0.3, height = 0.3,
              colour = "#E50914", alpha = 0.05) +
  scale_y_continuous(labels = function(y) ifelse(y == 0, "No", ifelse(y == 1, "Yes", y)),
                     breaks = c(0, 1)) +
  labs(x = "Number of films with same actor liked",
       y = "Viewed\nLord of The Rings") +
  theme_classic()

# Using the patchwork package I stich p1 to p4 together into a single figure
(p1 + p2) / (p3 + p4)

# A scatterplot for lotr ~ similar_user_ratings, jittered
p5 <- ggplot(netflix) +
  geom_jitter(aes(x = similar_user_ratings, y = lotr), 
              width = 0, height = 0.3,
              colour = "#E50914", alpha = 0.05) +
  scale_y_continuous(labels = function(y) ifelse(y == 0, "No", ifelse(y == 1, "Yes", y)),
                     breaks = c(0, 1)) +
  labs(x = "Proportion of similar users who liked LoTR",
       y = "Viewed\nLord of The Rings") +
  theme_classic()


# A scatterplot for lotr ~ mean_time_genre, jittered
p6 <- ggplot(netflix) +
  geom_jitter(aes(x = mean_time_genre, y = lotr), 
              width = 0.3, height = 0.3,
              colour = "#E50914", alpha = 0.05) +
  scale_y_continuous(labels = function(y) ifelse(y == 0, "No", ifelse(y == 1, "Yes", y)),
                     breaks = c(0, 1)) +
  labs(x = "Mean time spent watching fantasy films",
       y = "Viewed\nLord of The Rings") +
  theme_classic()

# A scatterplot for lotr ~ user_time, jittered
p7 <- ggplot(netflix) +
  geom_jitter(aes(x = user_time, y = lotr), 
              width = 0.3, height = 0.3,
              colour = "#E50914", alpha = 0.05) +
  scale_y_continuous(labels = function(y) ifelse(y == 0, "No", ifelse(y == 1, "Yes", y)),
                     breaks = c(0, 1)) +
  labs(x = "Time of day",
       y = "Viewed\nLord of The Rings") +
  theme_classic()

# A scatterplot for lotr ~ user_day, jittered
p8 <- ggplot(netflix) +
  geom_jitter(aes(x = user_day, y = lotr), 
              width = 0.3, height = 0.3,
              colour = "#E50914", alpha = 0.05) +
  scale_y_continuous(labels = function(y) ifelse(y == 0, "No", ifelse(y == 1, "Yes", y)),
                     breaks = c(0, 1)) +
  labs(x = "Day of week",
       y = "Viewed\nLord of The Rings") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 30, vjust = 0.5, hjust = 0.3))


# Using the patchwork package I stich p1 to p4 together into a single figure
(p5 + p6) / (p7 + p8)

# A scatterplot for lotr ~ fam_members, jittered
p9 <- ggplot(netflix) +
    annotation_raster(logo,
                      xmin = 8.3, xmax = 9.6,
                      ymin = -0.3, ymax = 0.3) +
  geom_jitter(aes(x = fam_members, y = lotr), 
              width = 0.3, height = 0.3,
              colour = "#E50914", alpha = 0.05) +
  scale_y_continuous(labels = function(y) ifelse(y == 0, "No", ifelse(y == 1, "Yes", y)),
                     breaks = c(0, 1)) +
  labs(x = "Number of accounts",
       y = "Viewed\nLord of The Rings") +
  theme_classic()
  
# A scatterplot for lotr ~ user_device, jittered
p10 <- ggplot(netflix) +
  geom_jitter(aes(x = user_device, y = lotr), 
              width = 0.3, height = 0.3,
              colour = "#E50914", alpha = 0.05) +
  scale_y_continuous(labels = function(y) ifelse(y == 0, "No", ifelse(y == 1, "Yes", y)),
                     breaks = c(0, 1)) +
  labs(x = "User device",
       y = "Viewed\nLord of The Rings") +
  theme_classic()

# A scatterplot for lotr ~ country, jittered
p11 <- ggplot(netflix) +
  geom_jitter(aes(x = country, y = lotr), 
              width = 0.3, height = 0.3,
              colour = "#E50914", alpha = 0.05) +
  scale_y_continuous(labels = function(y) ifelse(y == 0, "No", ifelse(y == 1, "Yes", y)),
                     breaks = c(0, 1)) +
  labs(x = "Country of registration",
       y = "Viewed\nLord of The Rings") +
  theme_classic()

# Using the patchwork package I stich p1 to p4 together into a single figure
(p10 + p11) / p9
```

\

### 5. Combine into a model that can answer your question.

\

Having gone through the previous steps, it's now time to run our model. Keep in mind that with this model, our objective is prediction, so we'll be running a model that includes all available covariates excluding one; `user_id` as including just this one covariate will require **15,000** parameters be estimated. We don't want that, nor do we have the sample size to support it.

Run the full model (not including `user_id`), using `glm()`.

* Hints:
  + Because $Bernoulli$ is really just a special case of the $Binomial$ distribution, we specify `family = binomial`
  + Do we need to specify number of success and number of failures like we did for $Binomial$ GLMs?
  + What is the default link function used by $Bernoulli$ GLMs?

```{r Q5, eval=TRUE, echo=SOLUTIONS, results=SOLUTIONS, collapse=TRUE}
mod1 <- glm(lotr ~ premium + age + genre_likes + actor_likes + similar_user_ratings +
              mean_time_genre + user_time + user_day + user_device + fam_members + country, 
            family = binomial(link = "logit"), 
            data = netflix)
```

\

### 6. Variable selection

Given that in the lecture I showed an instance where AIC and variable selection failed quite miserably, in this exercise, I wanted to include a scenario where it performs very well.

Note that this discussion below is also true for Likelihood Ratio Testing (LRT). In fact, AIC ends up being the equivalent to LRT, where the P-value threshold to 0.187 rather than 0.05 (see Sutherland et al., [2023](https://doi.org/10.1098/rspb.2023.1261])).

For that, we need to have a brief discussion about how AIC works, starting with how it is calculated:

$AIC = 2K - 2ln(\mathcal{\hat{L}})$

where $K$ is the number of parameters in our model, $ln$ is the natural log, and $\mathcal{\hat{L}}$ is the maximum likelihood value for our given model. (Note that in practice $-2ln(\mathcal{\hat{L}})$ is used in model fitting for reasons that are not important here).

Think back to the $Poisson$ GLM lecture where we walked through how $\mathcal{\hat{L}}$ was derived. In that example, we were just trying different values for each parameter until we hit the "sweet spot" - where our predicted values were closest to our observed values using a particular combination of parameter values. Basically, $\mathcal{\hat{L}}$ is a value that reflects how well a combination of parameter values results in predicted values that are as close as possible to our actual response variable.

Where AIC comes in, is that it uses this $\mathcal{\hat{L}}$ value and asks; "Are all of these parameters needed to get to the best fit?" That's why AIC include the $2K$ bit. Each parameter has a "cost" associated with it of $+2 AIC$ units; AIC is a fit-versus-cost trade-off. If the cost of including a parameter in our model does not sufficiently improve our likelihood, then it is considered to be uninformative, and AIC tells us it's not worth including in the model. The conventional threshold is that if the difference when removing a variable from a model is less than or equal to $2 \Delta AIC$ (where $\Delta$ just means difference), then the covariate can be removed.

Going through this process, we are left with the most parsimonious model; the model that has a desired level of accuracy (or prediction) that uses the fewest variables as possible to do so. This is why some statisticians (myself included) tend to think of AIC as a "with-in sample predictive" tool. (Contrast this with "out-of sample prediction" where we use a new dataset to see how well our model predicts the response variable of that *new* dataset.) All that means is; AIC is a tool that evaluates the predictive ability of a model, in predicting the data that you used to fit the model. With this view of AIC, a parsimonious model simply represents a model that has "good" predictive ability. Importantly, however, such models are not intended to offer insights into causation. Indeed, for causal inference, AIC can be quite harmful.

For example, consider the following scenario. We are interested in the association between ice cream sales and shark attacks. There is no direct causal relationship between these two variables. Instead, it is the number of beach visitors that determines *both* ice cream sales and shark attacks. 

Regardless of causal mechanisms, finding a set of parameter values that captures the association between ice cream sales and shark attacks is trivial for `glm()`. This is what `glm()` is designed to do after all - estimate associations. If we were to use AIC on this hypothetical model it would strongly support including ice cream sales in the model, because knowing how many ice creams have been sold is pretty much telling us how many people were at the beach.

Test it out if your skeptical:

```
set.seed(123) # set seed so results are consistent
N <- 200 # 200 beaches
visitors <- rpois(N, lambda = 10) # generate 200 visitor counts
# Note that icecream does not appear when simulating shark, just visitors
shark <- rbinom(N, size = 1, prob = plogis(-4 + 0.2 * visitors)) # shark attack
# Note that shark does not appear when simulating icecream, just visitors
icecream <- rpois(N, lambda = exp(-5 + 0.5 * visitors)) # number of ice creams
dat <- data.frame(visitors, shark, icecream) # combine into dataset
mod1 <- glm(shark ~ icecream, family = binomial, data = dat) # run bernoulli glm
drop1(mod1) # use AIC to do variable selection
# AIC of full model: 167.29
# AIC of model without icecream: 171.08
```

The upside of this is that including `icecream` is very useful if we want to make predictions of shark attacks. For example, if there are two beaches, the first with very few ice cream sales, and the second with lots. Which beach is more at risk of shark attacks? Clearly we can predict the second beach is at higher risk, we just don't know *why* (based on the model).

With that in mind, my view is that AIC is most useful, and least risky, when used for prediction modelling. There are alternatives to AIC, but AIC is still useful never-the-less. Let's use AIC and variable selection now in order to determine which covariates give us predictive power, and which we can simply ignore when trying to make accurate predictions.

Starting off with the full model and using `drop1()`, which covariates can be removed without reducing our predictive power?

```{r Q6.1, eval=TRUE, echo=SOLUTIONS, results=SOLUTIONS, collapse=TRUE}
drop1(mod1)
# Model:
# lotr ~ premium + age + genre_likes + actor_likes + similar_user_ratings + 
#     mean_time_genre + user_time + user_day + user_device + fam_members + 
#     country
#                      Df Deviance     AIC
# <none>                    8535.3  8585.3
# premium               1   8535.3  8583.3
# age                   1  14997.9 15045.9
# genre_likes           1   8576.9  8624.9
# actor_likes           1   8552.1  8600.1
# similar_user_ratings  1  15360.9 15408.9
# mean_time_genre       1  10091.2 10139.2
# user_time             2   8677.9  8723.9
# user_day              6   9012.2  9050.2
# user_device           3   9154.8  9198.8
# fam_members           1   8535.4  8583.4
# country               6   8543.7  8581.7

# From this, we're looking for when removing a covariate lowers AIC by 2 units
  # From the above model, these include:
  # premium
  # country
# fam_members is right on the threshold with a DeltaAIC of 1.9
  # There's just enough information in fam_members to warrant leaving it in the 
  # model
```

Using `drop1()` to identify which covariates can be removed, refit that model.

```{r Q6.2, eval=TRUE, echo=SOLUTIONS, results=SOLUTIONS, collapse=TRUE}
mod2 <- glm(lotr ~ age + genre_likes + actor_likes + similar_user_ratings +
              mean_time_genre + user_time + user_day + user_device + fam_members, 
            family = binomial(link = "logit"), 
            data = netflix)
```


\

### 7. Check your assumption(s).

\

As always, we want to check how well we're meeting the assumptions (which we can test).

Start off by using the methods that have served us well for the $Poisson$ adn $Binomial$ GLMs, (e.g. `plot(mod2)` and `summary()`). Are these plots useful? Can we calculate dispersion for a $Bernoulli$ GLM?

```{r Q7, eval=TRUE, echo=SOLUTIONS, results=SOLUTIONS, collapse=TRUE}
# Model diagnostic plots:
# Residuals vs Fitted
  # Normally we want to see no weird patterns, but Bernoulli's always have weird 
  # patterns. This figure is now pretty useless.
# Q-Q Residuals
  # We completely ignore this figure for GLMs.
# Scale-Location
  # Uselss for Bernoulli GLMs
# Residuals vs Leverage
  # Still useful, even for Bernoulli GLMs. We don't want any points to be close
  # to a Cook's distance of 1. Here we're pretty safe.
# Overall, the diagnostic plots are not useful for Bernoulli GlMs, other than
  # the Residuals vs Leverage check (which had no issue).

# Ideally we would do a check for over-dispersion, but we can't do this Bernoulli's,
  # so we ignore over-dispersion

# We're now in a position where we don't really know how well our model has performed
  # with the above checks. What to do?

par(mfrow = c(2,2)) # Show figures in 2 rows and 2 columns
plot(mod2, col = ifelse(netflix$lotr == 1, "red", "black")) # Plot diagnostics
par(mfrow = c(1,1)) # Reset so only 1 figure is shown
summary(mod2)       # Get the summary of the model (to check dispersion?)
```

\

The diagnostics tests we've used up to this point have largely failed us for Bernoulli GLMs. As such we need to think of alternative ways to try and check our assumptions. In this instance, we can use the method we discussed in the lecture where we extract the Pearson residuals from the model, and plot these against our explanatory covariates.

Extracting residuals is a pretty easy process. To do so, we use the code:

```
netflix$resid <- resid(mod2, type = "pearson")
```

With the above code, we're simply adding a new column to our original dataset that contains the Pearson residual error for each observation ($i$) based on the model that you fit (here, called `mod2`). Now we need to load a package and use the appropriate function to make plotting residuals and diagnosing a bit easier: `binnedplot` from the `arm` package.

Using these plots, identify any covariates you think we should be concerned about, and why.

Hints:
* For categorical variables, we can force these to be numeric, and therefore use `binnedplot()` by doing `binnedplot(y = dat$resid, x = as.numeric(dat$category), nclass = 3, xlab = "My categorical variable")`

```{r Q7.1, eval=TRUE, echo=SOLUTIONS, results=SOLUTIONS, collapse=TRUE}
# Extract residuals from model
netflix$resid <- resid(mod2, type = "pearson")

# Using binnedplot() from arm package
library(arm)

# For categorical covariates in the model
par(mfrow = c(2,2))
# We convert the categories to numeric using as.numeric()
binnedplot(y = netflix$resid, x = as.numeric(netflix$user_time), nclass = 3, xlab = "User time")
# Pretty good. Nothing that is concerning
binnedplot(y = netflix$resid, x = as.numeric(netflix$user_day), nclass = 7, xlab = "User day")
# Pretty good also if slightly too negative
binnedplot(y = netflix$resid, x = as.numeric(netflix$user_device), nclass = 8, xlab = "User device")
# We have to set nclass = 8 to get a bin for each device (4 device types)
# But plot suggests no issues

par(mfrow = c(3,2))
# For continuous covariates in the model
binnedplot(y = netflix$resid, x = netflix$age, nclass = 6, xlab = "Age")
# Very likely that age is not a linear effect
  # We go from lots of negative, to lots of positive error
  # Model is struggling to deal with age
  # Assumption of linearity with age is likely broken here
binnedplot(y = netflix$resid, x = netflix$genre_likes, nclass = 4, xlab = "Genre likes")
# Pretty good - mostly evenly spread around 0
binnedplot(y = netflix$resid, x = netflix$actor_likes, nclass = 4, xlab = "Actor likes")
# Pretty good - all points within bounds
  # Slightly more negative than we might like but ok
binnedplot(y = netflix$resid, x = netflix$similar_user_ratings, nclass = 4, xlab = "Similar ratings")
# Mostly ok. At low similar rating we are below bounds, but not terribly
binnedplot(y = netflix$resid, x = netflix$mean_time_genre, nclass = 4, xlab = "Mean time spent watching fantasy")
# Pretty good. At 100 hours of watch time, we are ever-so-slightly below line but it's ok
binnedplot(y = netflix$resid, x = netflix$fam_members, nclass = 4, xlab = "Number of family members")
# Pretty good
```

\

### 8. Interpret your model.

\

Having now fit our most parsimonious model, let's see what we've learnt from it. Use `summary()` to pull up the coefficients table and answer the following questions:

* How many parameters have been estimated by this model?
* How might we want to change data collection methods to make the model more efficient in terms of the number of parameters?
* What does the `user_dayFriday` Estimate represent?
* For every additional family member (`fam_members`), how much does the log odds ratio increase by?

```{r Q8, eval=TRUE, echo=SOLUTIONS, results=SOLUTIONS, collapse=TRUE}
summary(mod2)
# How many parameters have been estimated by this model?
  # There are a total of 18 parameters in this model. The number of parameters is

# How might we want to change data collection methods to make the model more efficient in terms of the number of parameters?
  # We have more parameter than covariates because of the categorical variables
  # So just three covariates (user_time, user_day and user_device) are using 11 parameters
  # Two of these (user_time and user_day) could be expressed as numbers but there 
  # are two complications if we do so.
  # For user_time, we have not been provided with the actual time, just a broad
  # window. So we'd need more accurate information to resolve this.
  # For user_day, we can already convert this to numeric, e.g. Monday = 1,
  # Sunday = 7 but this does create an issue. Because weeks are cyclical, the 
  # predicted probability to watch LoTR on Sunday needs to match up, in some manner,
  # with the predicated probability to watch LoTR on Monday.
  # There are techniques to do this, but we don't have the time to cover them on
  # this course. In such cases, having day of week as a categorical is actually a
  # pretty good work-around. If you're interested in the alternative way, look up
  # cyclical splines in Generalised Additive Models.

# * What does the `user_dayFriday` `Estimate` represent?
  # Hopefully this is starting to become second nature at this point. This is the 
  # difference in logit value for Friday, compared to Monday (our reference level).
  # For Friday, this model would predict a user is *less* likely to watch LoTR
  # than on Monday (changing the intercept by -0.0553916).
  # If your summary table looks different, it's most likely because you did not
  # set Monday to be your reference in user_day and Morning to be your reference
  # in user_time (or you set the user_device reference to something other than
  # Gaming Device). It's absolutely fine if so - all it means is that your
  # Estimate values will be different but, importantly, the effects will be exactly 
  # the same.
  # The corresponding P-value indicates that there's a 59% chance that this difference
  # is actually 0.

# * For every additional family member (`fam_members`), how much does the log odds 
# ratio increase by?
  # Adding one more family member decreases the logit value to watch LoTR by
  # -0.0055314. According to this model, single people are *very* slightly more 
  # likely to watch LoTR.
```

If you don't use P-values, and want a less cluttered summary table, the `arm` package (that we used to do `binnedplot()`) also includes a function called `display()`, which gives a less cluttered summary of a model fit. 

Give it a shot if you're interested.

```{r}
display(mod2)

# display() includes a reminder of the model you ran,
# The parameters and their estimate (coef.est), where
# coefficient is another name for parameter estimate.
# The standard error for each parameter (coef.se).
# An indicator of how many samples were used in fitting (n = )
# An indicator of how many parameters were estimated by the model (k = )
# And a report of residual deviance and null deviance.

# Personally, I prefer display() for being more concise and removing 
# information I do not care about
```


\

### 9. Create figures to show predicted relationships.

\

We're now in a position to show our predicted relationships. To do so, we're going to recycle the method we used in the $Binomial$ GLM exercise.

For these predictions, Netflix are especially interested in identifying which type of user to give targeted adverts to on **Sunday afternoons**, such that they are more likely to watch LoTR. For us, this means we want to make our predictions specific to Sunday afternoons.

So you don't have to flip back to the $Binomial$ GLM exercise, here's the code we used to make our predictions in yesterdays exercise.

```
# Create a fake dataset to feed into our model equation
synth_data <- expand.grid(
  n_staff = median(netflix$n_staff), 
  policy = "Implemented",        
  capacity = seq(
    from = min(netflix$capacity), 
    to = max(netflix$capacity),   
    length.out = 20))   
synth_data$pred <- predict(mod1, newdata = synth_data, se.fit = TRUE)
synth_data$pred <- plogis(pred$fit)
synth_data$low <- plogis(pred$fit - pred$se.fit * 1.96)
synth_data$upp <- plogis(pred$fit + pred$se.fit * 1.96)
```

Adapt this code for our current model (i.e. add in the relevant covariates to `expand.grid()`) to show the relationships for `age`, `genre_likes`, `actor_likes`, `similar_user_ratings`, `mean_time_genre`, `user_device` and `family members`

Your figures should resemble (but need not match exactly):

```{r Q9, eval=TRUE, echo=SOLUTIONS, results=SOLUTIONS, collapse=TRUE, fig.height=8, fig.show= ifelse(TRUE, "asis", "hide")}

# Load packages for plotting
library(ggplot2)
library(scales)
library(patchwork)

###### Age ########

synth_data <- expand.grid(
  user_time = "Afternoon",
  user_day = "Sunday",
  # Age is variable of interest for prediction
  age = seq(from = min(netflix$age), to = max(netflix$age), length.out = 50),
  # Will vary this across user device at the same time
  user_device = c("Gaming Device", "Mobile Device", "PC", "TV"),
  genre_likes = median(netflix$genre_likes), 
  actor_likes = median(netflix$actor_likes),    
  similar_user_ratings = median(netflix$similar_user_ratings),
  mean_time_genre = median(netflix$mean_time_genre),
  fam_members = median(netflix$fam_members)
)

# Get mean prediction and 95% CI on the response scale
pred <- predict(mod2, newdata = synth_data, se.fit = TRUE)
synth_data$pred <- plogis(pred$fit)
synth_data$low <- plogis(pred$fit - pred$se.fit * 1.96)
synth_data$upp <- plogis(pred$fit + pred$se.fit * 1.96)

# Plot for age
p1 <- ggplot(synth_data, aes(x = age, y = pred, ymin = low, ymax = upp, 
                       colour = user_device, fill = user_device)) +
  geom_ribbon(alpha = 0.3) +
  geom_line() +
  scale_color_brewer(palette = "Dark2") +
  scale_fill_brewer(palette = "Dark2") +
  scale_y_continuous(labels = percent, limits = c(0,1)) +
  theme_minimal() +
  labs(x = "Age of user",
       y = "Predicted probability to watch LoTR",
       colour = "User device",
       fill = "User device")

###### Genre likes ########

synth_data <- expand.grid(
  user_time = "Afternoon",
  user_day = "Sunday",
  # genre_likes is variable of interest for prediction
  genre_likes = seq(from = min(netflix$genre_likes), to = max(netflix$genre_likes), length.out = 50),
  # Will vary this across user device at the same time
  user_device = c("Gaming Device", "Mobile Device", "PC", "TV"),
  age = median(netflix$age), 
  actor_likes = median(netflix$actor_likes),    
  similar_user_ratings = median(netflix$similar_user_ratings),
  mean_time_genre = median(netflix$mean_time_genre),
  fam_members = median(netflix$fam_members)
)

# Get mean prediction and 95% CI on the response scale
pred <- predict(mod2, newdata = synth_data, se.fit = TRUE)
synth_data$pred <- plogis(pred$fit)
synth_data$low <- plogis(pred$fit - pred$se.fit * 1.96)
synth_data$upp <- plogis(pred$fit + pred$se.fit * 1.96)

# Plot for genre_likes
p2 <- ggplot(synth_data, aes(x = genre_likes, y = pred, ymin = low, ymax = upp, 
                       colour = user_device, fill = user_device)) +
  geom_ribbon(alpha = 0.3) +
  geom_line() +
  scale_color_brewer(palette = "Dark2") +
  scale_fill_brewer(palette = "Dark2") +
  scale_y_continuous(labels = percent, limits = c(0,1)) +
  theme_minimal() +
  labs(x = "Number of fantasy\nmedia liked",
       y = "Predicted probability to watch LoTR",
       colour = "User device",
       fill = "User device")

###### Actor likes ########

synth_data <- expand.grid(
  user_time = "Afternoon",
  user_day = "Sunday",
  # actor_likes is variable of interest for prediction
  actor_likes = seq(from = min(netflix$actor_likes), to = max(netflix$actor_likes), length.out = 50),
  # Will vary this across user device at the same time
  user_device = c("Gaming Device", "Mobile Device", "PC", "TV"),
  age = median(netflix$age), 
  genre_likes = median(netflix$genre_likes),    
  similar_user_ratings = median(netflix$similar_user_ratings),
  mean_time_genre = median(netflix$mean_time_genre),
  fam_members = median(netflix$fam_members)
)

# Get mean prediction and 95% CI on the response scale
pred <- predict(mod2, newdata = synth_data, se.fit = TRUE)
synth_data$pred <- plogis(pred$fit)
synth_data$low <- plogis(pred$fit - pred$se.fit * 1.96)
synth_data$upp <- plogis(pred$fit + pred$se.fit * 1.96)

# Plot for actor_likes
p3 <- ggplot(synth_data, aes(x = actor_likes, y = pred, ymin = low, ymax = upp, 
                       colour = user_device, fill = user_device)) +
  geom_ribbon(alpha = 0.3) +
  geom_line() +
  scale_color_brewer(palette = "Dark2") +
  scale_fill_brewer(palette = "Dark2") +
  scale_y_continuous(labels = percent, limits = c(0,1)) +
  theme_minimal() +
  labs(x = "Number of media with\ncast member liked",
       y = "Predicted probability to watch LoTR",
       colour = "User device",
       fill = "User device")

###### similar_user_ratings ########

synth_data <- expand.grid(
  user_time = "Afternoon",
  user_day = "Sunday",
  # similar_user_ratings is variable of interest for prediction
  similar_user_ratings = seq(from = min(netflix$similar_user_ratings), 
                             to = max(netflix$similar_user_ratings), 
                             length.out = 50),
  # Will vary this across user device at the same time
  user_device = c("Gaming Device", "Mobile Device", "PC", "TV"),
  genre_likes = median(netflix$genre_likes), 
  actor_likes = median(netflix$actor_likes),    
  age = median(netflix$age),
  mean_time_genre = median(netflix$mean_time_genre),
  fam_members = median(netflix$fam_members)
)

# Get mean prediction and 95% CI on the response scale
pred <- predict(mod2, newdata = synth_data, se.fit = TRUE)
synth_data$pred <- plogis(pred$fit)
synth_data$low <- plogis(pred$fit - pred$se.fit * 1.96)
synth_data$upp <- plogis(pred$fit + pred$se.fit * 1.96)

# Plot for similar_user_ratings
p4 <- ggplot(synth_data, aes(x = similar_user_ratings, y = pred, ymin = low, ymax = upp, 
                       colour = user_device, fill = user_device)) +
  geom_ribbon(alpha = 0.3) +
  geom_line() +
  scale_color_brewer(palette = "Dark2") +
  scale_fill_brewer(palette = "Dark2") +
  scale_y_continuous(labels = percent, limits = c(0,1)) +
  theme_minimal() +
  labs(x = "Proportion of similar\nusers who liked LoTR",
       y = "Predicted probability to watch LoTR",
       colour = "User device",
       fill = "User device")

###### mean_time_genre ########

synth_data <- expand.grid(
  user_time = "Afternoon",
  user_day = "Sunday",
  # mean_time_genre is variable of interest for prediction
  mean_time_genre = seq(from = min(netflix$mean_time_genre), 
                        to = max(netflix$mean_time_genre), 
                        length.out = 50),
  # Will vary this across user device at the same time
  user_device = c("Gaming Device", "Mobile Device", "PC", "TV"),
  genre_likes = median(netflix$genre_likes), 
  actor_likes = median(netflix$actor_likes),    
  similar_user_ratings = median(netflix$similar_user_ratings),
  age = median(netflix$age),
  fam_members = median(netflix$fam_members)
)

# Get mean prediction and 95% CI on the response scale
pred <- predict(mod2, newdata = synth_data, se.fit = TRUE)
synth_data$pred <- plogis(pred$fit)
synth_data$low <- plogis(pred$fit - pred$se.fit * 1.96)
synth_data$upp <- plogis(pred$fit + pred$se.fit * 1.96)

# Plot for mean_time_genre
p5 <- ggplot(synth_data, aes(x = mean_time_genre, y = pred, ymin = low, ymax = upp, 
                       colour = user_device, fill = user_device)) +
  geom_ribbon(alpha = 0.3) +
  geom_line() +
  scale_color_brewer(palette = "Dark2") +
  scale_fill_brewer(palette = "Dark2") +
  scale_y_continuous(labels = percent, limits = c(0,1)) +
  theme_minimal() +
  labs(x = "Mean time spent\nwatching fantasy",
       y = "Predicted probability to watch LoTR",
       colour = "User device",
       fill = "User device")

###### fam_members ########

synth_data <- expand.grid(
  user_time = "Afternoon",
  user_day = "Sunday",
  # fam_members is variable of interest for prediction
  fam_members = seq(from = min(netflix$fam_members), 
                    to = max(netflix$fam_members), 
                    length.out = 50),
  # Will vary this across user device at the same time
  user_device = c("Gaming Device", "Mobile Device", "PC", "TV"),
  genre_likes = median(netflix$genre_likes), 
  actor_likes = median(netflix$actor_likes),    
  similar_user_ratings = median(netflix$similar_user_ratings),
  mean_time_genre = median(netflix$mean_time_genre),
  age = median(netflix$age)
)

# Get mean prediction and 95% CI on the response scale
pred <- predict(mod2, newdata = synth_data, se.fit = TRUE)
synth_data$pred <- plogis(pred$fit)
synth_data$low <- plogis(pred$fit - pred$se.fit * 1.96)
synth_data$upp <- plogis(pred$fit + pred$se.fit * 1.96)

# Plot for fam_members
p6 <- ggplot(synth_data, aes(x = fam_members, y = pred, ymin = low, ymax = upp, 
                       colour = user_device, fill = user_device)) +
  geom_ribbon(alpha = 0.3) +
  geom_line() +
  scale_color_brewer(palette = "Dark2") +
  scale_fill_brewer(palette = "Dark2") +
  scale_y_continuous(labels = percent, limits = c(0,1)) +
  theme_minimal() +
  labs(x = "Number of family members",
       y = "Predicted probability to watch LoTR",
       colour = "User device",
       fill = "User device")

# Add all multiples into a single figure
design_layout <- "
AB
CD
EF
"
p1 + p2 + p3 + p4 + p5 + p6 + 
  plot_annotation(title = "Users to target") + 
  plot_layout(guides = "collect", axis_titles = "collect", design = design_layout)
```

Using your figures, what type of user should Netflix use targeted adverts on, to increase the probability that they watch LoTR?

```{r Q9.1, eval=TRUE, echo=SOLUTIONS, results=SOLUTIONS, collapse=TRUE}
# Netflix should target:
  # Users watching on TV or PC
  # Users under the age of 40
  # Users for whom >75% of similar users liked LoTR
  # Users who have spent > 200 hours on average watching fantasy
# The following do have help making a prediction but are weak
  # Users who have liked > 5 fantasy films
  # Users who have liked > 7.5 films with same actors
  # Users with no family members on their account
```


\

### 10. The Monkey's Paw

\

Having now fit the model and generated predicted relationships to allow Netflix to do targeted advertising, stop. Have a think again about the data. At the end of yesterday's exercise I explained how that dataset and model had broken the assumption of validity. Can you think of any issues here? Were there any assumptions we broke but that got left behind? What are the consequences of breaking any such assumptions?

\

### 11. (Optional) Exploring model diagnostics

As in previous exercises, below I include code to simulate a $Bernoulli$ dataset to allow you to explore the impact of sample size, model misspecification, and effect size, on model diagnostic plots. The *Data Generating Process* (DGP) for the dataset is:

$y_i \sim Bernoulli(p_i)$

$logit(p_i) = \beta_0 + \beta_1 \times x_{1,i} + \beta_2 \times x_{2,i} + \beta_3\times x_{3,i} + \beta_4 \times x_{1, i} \times x_{2,i}$

where you are free to decide what the values for the parameters ($\beta_{0,...,4}$) are.

I am also including three additional covariates ($Z_{1,...,3}$) which have no effect what-so-ever on $p$.

Rerun the simulation and analysis varying the sample size (e.g. `N <- 1000`), the effect sizes (e.g. `beta_0 <- 10`) or the formula of the `glm()` (e.g. remove the interaction). Check what effect this has on the generic diagnostic plots as well as the `binnedplots()` from the `arm` package.

```
# Set your seed to have the randomness be cosnsitent each time you run the code
# You can change this, or comment it out, if you want to embrase the randomness
set.seed(1234)

# Set your sample size
N <- 500

# Set the number of trials (must be 1 for Bernoulli)
k <- 1

# Create three continuous covariates
x1 <- runif(N, 0, 10)
x2 <- runif(N, 0, 10)
x3 <- runif(N, 0, 10)

# Set your parameter values
beta_0 <- 2.5   # This is the intercept (on link scale)
beta_1 <- 0.2   # This is the slope for the x1 variable (on link scale)
beta_2 <- -1.3  # This is the slope for the x2 variable (on link scale)
beta_3 <- 0.4   # This is the slope for the x3 variable (on link scale)
beta_4 <- 0.05  # The combined effect of x1 and x2 (on link scale)

# Generate your linear predictor on the link scale (i.e. log)
# We don't actually need to use log() here (it's already on the link scale)
linear_predictor_link <- beta_0 + beta_1 * x1 + beta_2 * x2 + beta_3 * x3 + beta_4 * x1 * x2

# Backtransform your linear predictor to the response scale (i.e. exponentiate)
linear_predictor_response <- plogis(linear_predictor_link)

# Generate your response variable using a Poisson random number generator (rpois)
y <- rbinom(N, size = k, prob = linear_predictor_response)

# Note that the above three lines of code are the equivalent to the equations:
# y ~ Bernoulli(p)
# logit(p) = beta_0 + beta_1 * x1 + beta_2 * x2 + beta_3 * x3 + beta_4 * x1 * x2

# Having simulated the data, we now include three additional covariates that do nothing
z1 <- rbeta(N, shape1 = 10, shape2 = 3)
z2 <- rgamma(N, shape = 15, rate = 2)
z3 <- runif(N, min = 0, max = 100)

# Store your data in a dataframe
dat <- data.frame(y, x1, x2, x3, z1, z2, z3)

# Run a Bernoulli GLM
fit <- glm(y ~ x1 + x2 + x3 + x1 : x2 + z1 + z2 + z3, 
           data = dat, 
           family = binomial)

# See if the model was able to estimate your parameter values 
# and what the dispersion is
summary(fit)

# See how well the model diagnostics perform
par(mfrow = c(2,2))
plot(fit)

# See how AIC reacts to the meaningless variables
drop1(fit)

# Check residuals using the binnedplots
dat$resid <- resid(fit, type = "pearson")
library(arm)
binnedplot(dat$resid, x = x1, nclass = 5, xlab = "x1")
binnedplot(dat$resid, x = x2, nclass = 5, xlab = "x2")
binnedplot(dat$resid, x = x3, nclass = 5, xlab = "x3")
binnedplot(dat$resid, x = z1, nclass = 5, xlab = "z1")
binnedplot(dat$resid, x = z2, nclass = 5, xlab = "z2")
binnedplot(dat$resid, x = z3, nclass = 5, xlab = "z3")
```

**End of the Bernoulli GLM - predicting Lord of the Rings viewership***
